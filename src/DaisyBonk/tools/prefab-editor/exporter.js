// exporter.js
import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/exporters/GLTFExporter.js';

function pad(n){ return n < 10 ? '0' + n : '' + n; }
function isoNow(){
    const d = new Date();
    return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())}T${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}Z`;
}
function asHexColor(c) {
    const color = new THREE.Color(c);
    return '0x' + color.getHexString();
}
function num(n) {
    // compact float with max 6 decimals
    return Number.parseFloat(n).toFixed(6).replace(/\.?0+$/,'');
}

export class Exporter {
    constructor(sceneMgr) {
        this.sceneMgr = sceneMgr;
    }

    // --- ES Module code generation ---
    generateCode({ id='prefab', type='prop', author='unknown', includeThreeImport=false } = {}) {
        const root = this.sceneMgr.root;
        const functionName = toFuncName(id || 'prefab');

        // Build code lines
        const lines = [];
        if (includeThreeImport) {
            lines.push(`import * as THREE from 'three';`);
            lines.push('');
        }
        lines.push(`// Auto-generated by DaisyBonk Prefab Editor on ${isoNow()}`);
        lines.push(`// Prefab ID: ${id} • Type: ${type} • Author: ${author}`);
        lines.push(`export function ${functionName}(){`);
        lines.push(`  const g = new THREE.Group();`);

        // Map from node ID to variable name and parent symbol
        let varCounter = 0;
        const symFor = new Map();
        symFor.set(root.userData.id, 'g');

        root.children.forEach(ch => this._emitNode(lines, ch, 'g', ++varCounter));

        lines.push(`  return g;`);
        lines.push(`}`);
        const code = lines.join('\n');

        const meta = {
            id, category: type, file: `${functionName}.js`, author, created: isoNow()
        };
        return { code, functionName, meta };
    }

    _emitNode(lines, node, parentSym, counterRef) {
        const nextName = suggestName(node);
        const sym = `${nextName}${counterRef}`;
        if (node.isMesh) {
            const { declGeom, declMat, setUV } = this._meshDecl(node);
            lines.push(`  const ${sym} = new THREE.Mesh(`);
            lines.push(`    ${declGeom},`);
            lines.push(`    ${declMat}`);
            lines.push(`  );`);
            this._emitTransform(lines, sym, node);
            if (setUV) lines.push(`  ${setUV}`);
            lines.push(`  ${parentSym}.add(${sym});`);
        } else {
            lines.push(`  const ${sym} = new THREE.Group();`);
            this._emitTransform(lines, sym, node);
            lines.push(`  ${parentSym}.add(${sym});`);
            let childIdx = 0;
            node.children.forEach(ch => {
                if (!ch.userData?.editable) return;
                this._emitNode(lines, ch, sym, ++childIdx);
            });
        }
    }

    _emitTransform(lines, sym, node) {
        // Position
        if (node.position.lengthSq() > 1e-10) {
            lines.push(`  ${sym}.position.set(${num(node.position.x)}, ${num(node.position.y)}, ${num(node.position.z)});`);
        }
        // Rotation
        if (Math.abs(node.rotation.x) > 1e-10 || Math.abs(node.rotation.y) > 1e-10 || Math.abs(node.rotation.z) > 1e-10) {
            lines.push(`  ${sym}.rotation.set(${num(node.rotation.x)}, ${num(node.rotation.y)}, ${num(node.rotation.z)});`);
        }
        // Scale
        if (Math.abs(node.scale.x-1) > 1e-10 || Math.abs(node.scale.y-1) > 1e-10 || Math.abs(node.scale.z-1) > 1e-10) {
            lines.push(`  ${sym}.scale.set(${num(node.scale.x)}, ${num(node.scale.y)}, ${num(node.scale.z)});`);
        }
        // Visibility
        if (node.visible === false) {
            lines.push(`  ${sym}.visible = false;`);
        }
        if (node.name) {
            lines.push(`  ${sym}.name = ${JSON.stringify(node.name)};`);
        }
    }

    _meshDecl(node) {
        const ud = node.userData || {};
        const st = ud.shapeType || (node.geometry?.type?.replace('Geometry','')) || 'Mesh';
        const p = ud.params || {};
        let geom = null;

        const g = (name, args) => `new THREE.${name}(${args})`;

        switch (st) {
            case 'Box': geom = g('BoxGeometry', [p.w||1,p.h||1,p.d||1,p.ws||1,p.hs||1,p.ds||1].map(num).join(', ')); break;
            case 'Sphere': geom = g('SphereGeometry', [p.r||.5,p.w||16,p.h||12].map(num).join(', ')); break;
            case 'Cylinder': geom = g('CylinderGeometry', [p.rt||.5,p.rb||.5,p.h||1,p.rs||24,p.hs||1,!!p.open].map(x=>typeof x==='boolean'?x: num(x)).join(', ')); break;
            case 'Cone': geom = g('ConeGeometry', [p.r||.5,p.h||1,p.rs||24,p.hs||1,!!p.open].map(x=>typeof x==='boolean'?x: num(x)).join(', ')); break;
            case 'Torus': geom = g('TorusGeometry', [p.r||.5,p.tube||.2,p.rs||16,p.ts||24,p.arc||Math.PI*2].map(num).join(', ')); break;
            case 'Dodecahedron': geom = g('DodecahedronGeometry', [p.r||.6,p.detail||0].map(num).join(', ')); break;
            case 'Capsule': geom = g('CapsuleGeometry', [p.r||.35,p.len||.8,p.cs||8,p.rs||16].map(num).join(', ')); break;
            case 'Plane': geom = g('PlaneGeometry', [p.w||1,p.h||1,p.ws||1,p.hs||1].map(num).join(', ')); break;
            case 'Octahedron': geom = g('OctahedronGeometry', [p.r||.6,p.detail||0].map(num).join(', ')); break;
            case 'Icosahedron': geom = g('IcosahedronGeometry', [p.r||.6,p.detail||0].map(num).join(', ')); break;
            default:
                // Unknown primitive — fallback to BufferGeometry clone (not ideal for readable code)
                geom = `/* Unsupported primitive: ${st}. Replace with your own geometry. */ new THREE.BoxGeometry(1,1,1)`;
                break;
        }

        const matType = (ud.materialType === 'MeshPhysicalMaterial') ? 'MeshPhysicalMaterial' : 'MeshStandardMaterial';
        const mp = ud.materialProps || {};
        const matArgs = [];
        if (mp.color) matArgs.push(`color:${asHexColor(mp.color)}`);
        if (typeof mp.metalness === 'number') matArgs.push(`metalness:${num(mp.metalness)}`);
        if (typeof mp.roughness === 'number') matArgs.push(`roughness:${num(mp.roughness)}`);
        const mat = `new THREE.${matType}({ ${matArgs.join(', ')} })`;

        let setUV = '';
        if (node.material?.map) {
            const rep = node.material.map.repeat, off = node.material.map.offset;
            setUV = `${node.name ? `${JSON.stringify(node.name)}` : sym}/*map*/; /* Attach texture at runtime. */`;
            // We can't reference the symbol name here; UV settings are better applied in-runtime once map is loaded.
            // Instead, we emit comments below:
            setUV = `// Note: assign a texture map to this mesh at runtime if desired.\n  // Example:\n  // ${node.name || 'mesh'}.material.map = new THREE.TextureLoader().load('path/to.png');\n  // ${node.name || 'mesh'}.material.map.repeat.set(${num(rep.x)}, ${num(rep.y)});\n  // ${node.name || 'mesh'}.material.map.offset.set(${num(off.x)}, ${num(off.y)});`;
        }

        return { declGeom: geom, declMat: mat, setUV };
    }

    // --- Export helpers ---
    downloadText(filename, text) {
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 1500);
    }

    copyToClipboard(text) {
        return navigator.clipboard?.writeText(text);
    }

    exportGLB(rootGroup, filename='prefab.glb') {
        const exporter = new GLTFExporter();
        exporter.parse(rootGroup, (bin) => {
            const blob = new Blob([bin], { type: 'model/gltf-binary' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 1500);
        }, { binary: true, trs: false, onlyVisible: true, embedImages: true });
    }

    exportGLTF(rootGroup, filename='prefab.gltf') {
        const exporter = new GLTFExporter();
        exporter.parse(rootGroup, (gltf) => {
            const json = JSON.stringify(gltf, null, 2);
            this.downloadText(filename, json);
        }, { binary: false, trs: false, onlyVisible: true, embedImages: true });
    }

    exportThreeJSON(rootGroup, filename='prefab.json') {
        const json = rootGroup.toJSON();
        const text = JSON.stringify(json);
        this.downloadText(filename, text);
    }
}

// --- utils ---
function toFuncName(id) {
    const clean = (id || 'Prefab').replace(/[^a-zA-Z0-9]+/g, ' ').trim().split(/\s+/).map(s => s[0].toUpperCase()+s.slice(1)).join('');
    return `make${clean}Mesh`;
}

function suggestName(node) {
    const base = node.isMesh ? 'mesh' : 'group';
    const n = (node.name || '').trim().replace(/\s+/g,'_').replace(/[^\w]/g,'');
    return n ? n.toLowerCase() : base;
}
